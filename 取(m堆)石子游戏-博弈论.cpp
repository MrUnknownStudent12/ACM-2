#include <iostream>
using namespace std;

int main()
{
    int n;
    while (scanf("%d",&n)&&n) {
        int i,j,k=0,a[200010];
        for (i=0; i<n; i++) {
            scanf("%d",&a[i]);
            k=k^a[i];
        }
        if (!k)
            printf("No\n");
        else {
            printf("Yes\n");
            for (i=0; i<n; i++) {
                j=k^a[i];
                if (j<a[i]) {
                    printf("%d %d\n",a[i],j);
                }
            }
        }
    }
    return 0;
}
/*
 Nim游戏是博弈论中最经典的模型（之一？），它又有着十分简单的规则和无比优美的结论
 　　Nim游戏是组合游戏(Combinatorial Games)的一种，准确来说，属于“Impartial Combinatorial Games”（以下简称ICG）。满足以下条件的游戏是ICG（可能不太严谨）：1、有两名选手；2、两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动；3、对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； 4、如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。根据这个定义，很多日常的游戏并非ICG。例如象棋就不满足条件3，因为红方只能移动红子，黑方只能移动黑子，合法的移动集合取决于轮到哪名选手操作。
 　　通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。
 　　这游戏看上去有点复杂，先从简单情况开始研究吧。如果轮到你的时候，只剩下一堆石子，那么此时的必胜策略肯定是把这堆石子全部拿完一颗也不给对手剩，然后对手就输了。如果剩下两堆不相等的石子，必胜策略是通过取多的一堆的石子将两堆石子变得相等，以后如果对手在某一堆里拿若干颗，你就可以在另一堆中拿同样多的颗数，直至胜利。如果你面对的是两堆相等的石子，那么此时你是没有任何必胜策略的，反而对手可以遵循上面的策略保证必胜。如果是三堆石子……好像已经很难分析了，看来我们必须要借助一些其它好用的（最好是程式化的）分析方法了，或者说，我们最好能够设计出一种在有必胜策略时就能找到必胜策略的算法。
 　　定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-position。
 　　按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。
 　　以Nim游戏为例来进行一下计算。比如说我刚才说当只有两堆石子且两堆石子数量相等时后手有必胜策略，也就是这是一个P-position，下面我们依靠定义证明一下(3,3)是一个P是一个P是一个P-position。首先(3,3)的子局面（也就是通过合法移动可以导致的局面）有(0,3)(1,3)(2,3)（显然交换石子堆的位置不影响其性质，所以把(x,y)和(y,x)看成同一种局面），只需要计算出这三种局面的性质就可以了。 (0,3)的子局面有(0,0)、(0,1)、(0,2)，其中(0,0)显然是P-position，所以(0,3)是N-position（只要找到一个是P-position的子局面就能说明是N-position）。(1,3)的后继中(1,1)是P-position（因为(1,1)的唯一子局面(0,1)是N-position），所以(1,3)也是N-position。同样可以证明(2,3)是N-position。所以(3,3)的所有子局面都是N-position，它就是P-position。通过一点简单的数学归纳，可以严格的证明“有两堆石子时的局面是P-position当且仅当这两堆石子的数目相等”。
 　　根据上面这个过程，可以得到一个递归的算法——对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P-position，那么向这个子局面的移动就是必胜策略。当然，可能你已经敏锐地看出有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。但问题是，利用这个算法，对于某个Nim游戏的局面(a1,a2,...,an)来说，要想判断它的性质以及找出必胜策略，需要计算O(a1*a2*...*an)个局面的性质，不管怎样记忆化都无法降低这个时间复杂度。所以我们需要更高效的判断Nim游戏的局面的性质的方法。
 　　直接说结论好了。(Bouton's Theorem)对于一个Nim游戏的局面(a1,a2,...,an)，它是P-position当且仅当a1^a2^...^an=0，其中^表示异或(xor)运算。怎么样，是不是很神奇？我看到它的时候也觉得很神奇，完全没有道理的和异或运算扯上了关系。但这个定理的证明却也不复杂，基本上就是按照两种position的证明来的。
 　　根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题： 1、这个判断将所有terminal position判为P-position；2、根据这个判断被判为N-position的局面一定可以移动到某个P-position；3、根据这个判断被判为P-position的局面无法移动到某个P-position。
 　　第一个命题显然，terminal position只有一个，就是全0，异或仍然是0。
 　　第二个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k<ai一定成立。则我们可以将ai改变成ai'=ai^k，此时a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。
 　　第三个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0。因为异或运算满足消去率，由a1^a2^...^an=a1^a2^...^ai'^...^an可以得到ai=ai'。所以将ai改变成ai'不是一个合法的移动。证毕。
 　　根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。
 
 问题
 有N块石头和两个玩家A和B，玩家A先将石头分成若干堆，然后按照BABA……的顺序不断轮流取石头，能将剩下的石头一次取光的玩家获胜。每次取石头时，每个玩家只能从若干堆石头中任选一堆，取这一堆石头中任意数目（大于1）个石头。
 请问：玩家A有必胜策略吗？要怎么分配和取石头才能保证自己有把握取胜？
 解法与分析
 据说，该游戏起源于中国，英文名字叫做“NIM”，是由广东话“拈”（取物之意）音译而来，经由当年到美洲打工的华人流传出去，这个游戏一个常见的变种是将十二枚硬币分三列排成 [3，4，5] 再开始玩 。我们这里讨论的是一般意义上的“拈”游戏。
 言归正传，在面试者咄咄逼人的目光下，你要如何着手解决这个问题？
 在面试中，面试者考察的重点不是“what”——能否记住某道题目的解法，某件历史事件发生的确切年代，C++语言中关于类的继承的某个规则的分支等。面试者很想知道的是“how”——应聘者是如何思考和学习的。
 所以，应聘者得展现自己的思路。解答这类问题应从最基本的特例开始分析。我们用N表示石头的堆数，M表示总的石头数目。
 当N=1时，即只有一堆石头——显然无论你放多少石头，你的对手都能一次全拿光，你不能这样摆。
 当N=2时，即有两堆石头，最简单的情况是每堆石头中各有一个石子（1，1）——先让对手拿，无论怎样你都可以获胜。我们把这种在双方理性走法下，你一定能够赢的局面叫作安全局面。
 当N = 2，M > 2时，既然（1, 1）是安全局面，那么（1, X）都不是安全局面，因为对手只要经过一次转换，就能把（1, X）变成（1, 1），然后该你走，你就输了。既然（1, X）不安全，那么（2, 2）如何？经过分析，（2，2）是安全的，因为它不能一步变成（1，1）这样的安全局面。这样我们似乎可以推理（3, 3）、（4, 4），一直到（X, X）都是安全局面。
 于是我们初步总结，如果石头的数目是偶数，就把它们分为两堆，每堆有同样多的数目。这样无论对手如何取，你只要保证你取之后是安全局面（X, X），你就能赢。
 好，如果石头数目是奇数个呢？
 当M=3的时候，有两种情况，（2, 1）、（1, 1, 1），这两种情况都会是先拿者赢。
 当M=5的时候，和M=3类似。无论你怎么摆，都会是先拿者赢。
 若M=7呢？情况多起来了，头有些晕了，好像也是先拿者赢。
 我们在这里得到一个很重要的阶段性结论：
 当摆放方法为（1, 1,…, 1）的时候，如果1的个数是奇数个，则先拿者赢；如果1的个数是偶数个，则先拿者必输。
 当摆放方法为（1, 1,…, 1, X）（多个1，加上一个大于1的X）的时候，先拿者必赢。因为：
 如果1有奇数个，先拿者可以从（X）这一堆中一次拿走X-1个，剩下偶数个1——接下来动手的人必输。
 如果有偶数个1，加上一个X，先拿者可以一次把X都拿光，剩下偶数个1——接下来动手的人也必输。
 当 然，游戏是两个人玩的，还有其他的各种摆法，例如当M = 9的时候，我们可以摆为（2, 3, 4）、（1, 4, 4）、（1, 2, 6），等等，这么多堆石头，它们既互相独立，又互相牵制，那如何分析得出致胜策略呢？关键是找到在这一系列变化过程中有没有一个特性始终决定着输赢。这个时候，就得考验一下真功夫了，我们要想想大学一年级数理逻辑课上学的异或（XOR）运算。异或运算规则如下：
 XOR（0, 0）= 0
 XOR（1, 0）= 1
 XOR（1, 1）= 0
 首先我们看整个游戏过程，我们从N堆石头（M1, M2, …, Mn）开始，双方斗智斗勇，石头一直递减到全部为零（0, 0,…, 0）。
 当M为偶数的时候，我们的取胜策略是把M分成相同的两份，这样就能取胜。
 开始：（M1, M1）     它们异或的结果是XOR（M1, M1）= 0
 中途：（M1, M2）     对手无论怎样从这堆石头中取，XOR（M1, M2）!= 0
 我方：（M2, M2）     我方还是把两堆变相等。XOR（M2, M2）= 0
 …
 最后：（M2, M2）     我方取胜
 类似的，若M为奇数，我们把石头分成（1, 1, …,1）奇数堆的时候，XOR（1, 1,…,1）[奇数个] !=0。而这时候，对方可以取走一整堆，XOR（1, 1,…, 1）[偶数个]=0，如此下去，我方必输。
 我们推广到M为奇数，但是每堆石头的数目不限于1的情况，看看XOR值的规律：
 开始：（M1, M2, …, Mn）  XOR（M1, M2, … Mn）=？
 中途：（M1’, M2’, … Mn’）  XOR（M1’, M2’, … Mn’）=？
 最后：（0, 0, …, 0）   XOR（0，0，… 0）=0
 不幸的是，可以看出，当有奇数个石头时，无论你如何分堆，XOR（M1, M2, … Mn）总是不等于0！因为必然会有奇数堆有奇数个石头（二进制表示最低位为1），异或的结果最低位肯定为1。             [结论1]
 再不幸的是，还可以证明，当XOR（M1, M2, … Mn）!= 0时，我们总是只需要改变一个Mi的值，就可以让XOR（M1, M2, …Mi’，… Mn）= 0。    [结论2]
 更不幸的是，又可以证明，当XOR（M1, M2, … Mn）= 0时，对任何一个M值的改变（取走石头），都会让XOR（M1, M2, …Mi’，… Mn）! = 0。    [结论3]
 有了这三个“不幸”的结论，我们不得不承认，当M为奇数时，无论怎样分堆，总是先动手的人赢。
 还不信？那我们试试看：当M=9，随机分堆为（1，2，6）
 开始：（1，2，6）
 1=0 0 1
 2=0 1 0
 6=1 1 0
 XOR=1 0 1  即XOR（1，2，6）!=0
 B先手：（1, 2, 3），即从第三堆取走三个，得到（1，2，3）
 1=0 0 1
 2=0 1 0
 3=0 1 1
 XOR=0 0 0  所以，XOR（1，2，3）=0
 A方：（1, 2, 2）XOR（1, 2, 2）!=0。
 B方：（0, 2, 2）XOR （0, 2, 2）=0
 ……A方继续顽抗……
 B方最后：（0, 0, 0），XOR（0, 0, 0）= 0
 好了，通过以上的分析，我们不但知道了这类问题的答案，还知道了游戏的规律，以及如何才能赢。XOR，这个我们很早就学过的运算，在这里帮了大忙。我们应该对XOR说Orz才对！
 有兴趣的读者可以写一个程序，返回当输入为（M1, M2, …, Mn）的时候，到底如何取石头，才能有赢的可能。比如，当输入为（3, 4, 5）的时候 ，程序返回（1, 4, 5）——这样就转败为胜了！
 **************************
 Problem Description
 m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.
 
 
 Input
 输入有多组.每组第1行是m,m<=200000. 后面m个非零正整数.m=0退出.
 
 
 Output
 先取者负输出No.先取者胜输出Yes,然后输出先取者第1次取子的所有方法.如果从有a个石子的堆中取若干个后剩下b个后会胜就输出a b.参看Sample Output.
 
 
 Sample Input
 2
 45 45
 3
 3 6 9
 5
 5 7 8 9 10
 0
 
 
 Sample Output
 No
 Yes
 9 5
 Yes
 8 1
 9 0
 10 3
*/