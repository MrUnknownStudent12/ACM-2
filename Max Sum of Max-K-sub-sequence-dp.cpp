#include <iostream>
#include <queue>
using namespace std;
int a[200010],sum[200010];
const int inf=0x2fffffff;

int main()
{
    int t;
    scanf("%d",&t);
    while (t--) {
        int i,n,m;
        scanf("%d%d",&n,&m);
        for (i=1; i<=n; i++) {
            scanf("%d",&a[i]);
            sum[i]=sum[i-1]+a[i];
        }
        for (i=n+1; i<n+m; i++)
            sum[i]=sum[i-1]+a[i-n];
        int len=n+m,cur,end,ans=-inf;
        deque<int> q;
        q.clear();
        for (i=1; i<len; i++) {
            while (!q.empty()&&sum[i-1]<sum[q.back()])
                q.pop_back();
            while (!q.empty()&&q.front()<(i-m))
                q.pop_front();
            q.push_back(i-1);
            if (sum[i]-sum[q.front()]>ans) {
                ans=sum[i]-sum[q.front()];
                cur=q.front()+1;
                end=i;
            }
        }
        printf("%d %d %d\n",ans,cur,(end>n?end%n:end));
    }
    return 0;
}
/*
 有上界的最大子段和问题（单调队列）
 题目大意：给定n个数a1,a2,...,an,构成循环序列，求一个最大的连续子段和。要求：这个子段的长度小于等于K。
 算法分析
 因为序列是环状的，所以可以在序列后面复制一段（或者复制前k个数字）。如果用s[i]来表示复制过后的序列的前 i 个数的和，那么任意一个子序列 [ i...j ]的和就等于s[j] - s[i-1]。对于每一个j，用s[j]减去最小的一个s[i] (i >= j-k+1)就可以得到以j为终点长度不大于k的最大的子序列和了。将原问题转化为这样一个问题后，就可以用单调队列解决了。
 
 
 
 单调队列即保持队列中的元素单调递增（或递减）的这样一个队列，可以从两头删除，只能从队尾插入。单调队列的具体作用在于，由于保持队列中的元素满足单调性，对于上述问题中的每个j，可以用O(1)的时间找到对应的s[i]。（保持队列中的元素单调递增的话，队首元素便是所要的元素）。
 
 
 
 维护方法：对于每个j，我们插入s[j-1]（为什么不是s[j]？队列里面维护的是区间开始的下标，j是区间结束的下标），插入是从队尾插入。为了保证队列的单调性，我们从队尾开始删除元素，直到队尾元素比当前需要插入的元素优（本题中是值比待插入的元素小，位置比待插入元素考前，不过后面这一个条件可以不考虑），就将当前元素插入到队尾。之所以可以将之前的队列尾部元素全部删除，是因为他们已经不可能成为最优的元素了，因为当前要插入的元素位置比他们靠前，值比他们小。我们要找的，是满足（i >= j - k + 1）的 i 中最小的s[i]，位置越大越可能成为后面的 j 的最优s[i].
 
 在插入元素后，从队首开始，将不符合限制条件（i >= j - k + 1）的元素全部删除，此时队列一定不为空。（因为刚刚插入了一个一定符合条件的元素）
 
 
 
 我们为什么需要单调队列呢？在多重背包问题中，我们知道一个O(V*N)的解法是依靠一个单调队列进行状态的转移，以保证每次O(1)的取最优值，并最终是的总的转移成本得到O(1)的摊销！在这里我们的做法异曲同工，同样利用普通k长队列按自然顺序保存状态，利用负主队列实现k个状态的单调排列。
*/