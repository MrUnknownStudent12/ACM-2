#include <iostream>
using namespace std;

int n,m,a[101][101],dp[101][101];

int main()
{
    int t;
    scanf("%d",&t);
    while (t--) {
        int i,j,i1,j1;
        scanf("%d%d",&n,&m);
        memset(dp, 0, sizeof(dp));
        dp[1][1]=1;
        for (i=1; i<=n; i++)
            for (j=1; j<=m; j++)
                scanf("%d",&a[i][j]);
        for (i=1; i<=n; i++)
            for (j=1; j<=m; j++)
                for (i1=0; i1<=a[i][j]; i1++)
                    for (j1=0; j1+i1<=a[i][j]; j1++)
                        if (i+i1<=n&&j+j1<=m&&i+i1>=1&&j+j1>=1&&(i1+j1))
                            dp[i+i1][j+j1]=(dp[i][j]+dp[i+i1][j+j1])%10000;
        printf("%d\n",dp[n][m]);
    }
    return 0;
}
/*
 Problem Description
 这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点(1,1)走到棋盘的终点(n,m)。游戏的规则描述如下：
 1.机器人一开始在棋盘的起始点并有起始点所标有的能量。
 2.机器人只能向右或者向下走，并且每走一步消耗一单位能量。
 3.机器人不能在原地停留。
 4.当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。
 
 
 如上图，机器人一开始在(1,1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2,4)
 
 点，当他到达(2,4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达(6,6)点。
 我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000取模。
 
 
 Input
 第一行输入一个整数T,表示数据的组数。
 对于每一组数据第一行输入两个整数n,m(1 <= n,m <= 100)。表示棋盘的大小。接下来输入n行,每行m个整数e(0 <= e < 20)。
 
 
 Output
 对于每一组数据输出方式总数对10000取模的结果.
 
 
 Sample Input
 1
 6 6
 4 5 6 6 4 3
 2 2 3 1 7 2
 1 1 4 6 2 7
 5 8 4 3 9 5
 7 6 6 2 1 5
 3 1 1 3 7 2
 
 
 Sample Output
 3948
*/