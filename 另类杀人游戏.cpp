#include <iostream>
using namespace::std;

int main()
{
	int k;
	cin >> k;
	while(k--)
	{
		int n,m,s,num,i=0,j,ans=1,start,a[10001]={0};
		cin >> n >> m >> s;
		s--;
		num=n;
		start=n-s;
		start%=n;
		while(num>2)
		{
			start+=(m-1);
			start%=num;
			if(start==0)
				start++;
			a[i]=start;
			i++;
			num--;
		}
		for(j=i-1;j>=0;j--)
			if(a[j]<=ans)
				ans++;
		ans+=s;
		ans%=n;
		cout << ++ans << '\n';
	}
	return 0;
}
/*
首先，把整个圆圈以Austin为第1个排列好，其他人按顺序编号，然后通过取模运算，
 每次可以求出这回合杀掉的人的编号，记下这个编号，然后把剩下的人重新以Austin为第1个，
 顺次编号，继续杀人。直到只剩下两个人为止。然后根据记下的编号进行倒推，求出最后剩下的那个人的初始编号即可。
*/
/*
 Problem description
 周末的晚上，百度的员工们总喜欢聚集在公司的会议室玩杀人游戏。从1警1匪到n警n匪，他们尝试了几乎所有流行的杀人游戏规则。终于有一天，连最热衷杀人游戏的“杀人不眨眼”的Austin也开始对无休止的辩论感到厌烦。于是，他决定改变他的一贯作风，他开始变成了一个“杀人不睁眼”的杀手。
 如何做到“杀人不睁眼”呢？Austin早已构思好他的杀人计划：
 N个人（包括Austin）坐成一圈玩杀人游戏，按顺时针编号 1 2 3 4 ... ...
 Austin从1号开始顺时针开始数到第m号就杀掉第一个人，被杀掉的人要退出游戏。
 如果第m个人恰好是Austin自己，他就杀掉他顺时针方向的下一个人。
 Austin从被杀的人的下一个顺时针数m个人，把第m个杀掉。
 重复2-4，直至杀掉所有人。
 Austin把这个杀人计谋告诉了法官小k，他便可以闭起眼睛杀人啦。作为一个正直善良的法官，小k当然不能让残忍的Austin得逞，于是，她偷偷把Austin的杀人计划告诉了作为警察的你，聪明的百度之星。现在，你的任务是活到最后，与“杀人不睁眼”的Austin对决。
 
 
 Input
 第一个行包含一个整数K，表示有K组测试数据。 对于每组测试数据三个整数：
 N，M，T，(3<=N<=10000,1<=M,T<=10000) 
 分别表示参与游戏的人数，Austin每隔M个人会杀掉一人，Austin初始位置的标号。
 
 
 Output
 每个测试数据输出一个整数。
 你需要选择的初始位置的序号，以确保最后剩下的两个人是你与Austin。
 
 
 Sample Input
 2
 7 4 1
 7 4 1
 Sample Output
 5
 5
*/