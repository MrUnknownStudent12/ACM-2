#include <iostream>
using namespace std;

int cal(int n)
{
    int sum=0;
    while (n) {
        sum=sum*10+n%10;
        n/=10;
    }
    return sum;
}

int main()
{
    int n;
    while (~scanf("%d",&n)) {
        int i,cnt=0,b[1000]={0};
        b[cnt++]=n;
        while (n!=cal(n)) {
            n+=cal(n);
            b[cnt++]=n;
        }
        cout << cnt-1 << '\n';
        for (i=0; i<cnt; i++) {
            if (i)
                cout << "--->";
            cout << b[i];
        }
        cout << '\n';
    }
    return 0;
}
/*
 Problem Description
 一个正整数，如果从左向右读（称之为正序数）和从右向左读（称之为倒序数）是一样的，这样的数就叫回文数。任取一个正整数，如果不是回文数，将该数与他的倒序数相加，若其和不是回文数，则重复上述步骤，一直到获得回文数为止。例如：68变成154（68+86），再变成605（154+451），最后变成1111（605+506），而1111是回文数。于是有数学家提出一个猜想：不论开始是什么正整数，在经过有限次正序数和倒序数相加的步骤后，都会得到一个回文数。至今为止还不知道这个猜想是对还是错。现在请你编程序验证之。
 
 
 Input
 每行一个正整数。
 特别说明：输入的数据保证中间结果小于2^31。
 
 
 Output
 对应每个输入，输出两行，一行是变换的次数，一行是变换的过程。
 
 
 Sample Input
 27228
 37649
 
 
 Sample Output
 3
 27228--->109500--->115401--->219912
 2
 37649--->132322--->355553
*/