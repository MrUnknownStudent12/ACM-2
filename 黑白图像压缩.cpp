#include <iostream>
using namespace::std;
int a[80000],b[80000];
int main()
{
	long int m;
	int i,j,n,k=0,lab;
	cin >> m;
	n=m/8;
	for(i=0;i<n;i++)
		cin >> a[i];
	for(i=0;i<n;i++)
		for(j=7;j>=0;j--)
		{
			k=i*8+j;
			b[k]=a[i]%2;
			a[i]/=2;
		}
	for(i=1,lab=1;i<m;i++)
	{
		if(b[i]!=b[i-1])
		{
			if(b[i-1]==1)
				printf("%d ",lab+128);
			if(b[i-1]==0)
				printf("%d ",lab);
			lab=1;
			continue;
		}
		lab++;
	}
	if(b[i-1]==1)
		printf("%d \n",lab+128);
	else 
		printf("%d \n",lab);
	return 0;
}
/*
#include <stdio.h>
#include <iostream>
short bit[8]={128,64,32,16,8,4,2,1};
int ele,have,num,i;
bool ta,tb;

int main()
{
	scanf("%d",&num);
	scanf("%d",&ele);//第一个数
	ta=(bit[0]&ele);have=1;//第一位
	for(i=1;i<num;i++)
	{
		if(i%8==0)scanf("%d",&ele);//当
		tb=bit[i%8]&ele;
		if(ta==tb)++have;//当下一位相同，
		else//否则
		{
			printf("%d ",have|(ta?bit[0]:0));
			have=1;ta=tb;
		}
	}
	printf("%d ",have|(ta?bit[0]:0));//输出最后一项
	return 0;
}
*/
/*
 Problem description
 选修基础生物基因学的时候,小可可在家里做了一次图像学试验.她知道:整个图像其实就是若干个图像点(称作像素)的序列,假定序列中像素的个数总是8的倍数,于是每八个像素可以转换成一个叫做字节的数,从而这个表示图像的像素序列就被转换成了字节的序列.所谓的字节就是一个八位的二进制数(当然,为了便于书写,人们经常用它的十进制形式来表示).这八个像素从前向后依次对应于字节从高位到低位的八个位,用0来表示白色像素,1来表示黑色像素.这种表示方法叫做位图法.例如字节序列210,0,255表示了8*3=24个像素,由于对应的二进制形式是11010010,00000000,11111111,所以这24个像素的颜色依次是黑,黑,白,黑,白,白,黑,白,白,白,白,白,白,白,白,白,黑,黑,黑,黑,黑,黑,黑,黑.
 
 小可可想:其实图像中存在着很多连续的同色像素段,也许换一种方式表达图像能够减少图像的数据量.她的思路是:把像素按照颜色分成若干个片段,同一个片段中各像素颜色相同,且连续的同色像素都在同一个片段中.同时已知每个片段的最大长度小于128.每一个像素片段都是用一个二进制字节量来表示,最高位表示片段中像素的颜色,而低七位表示片段中像素的数目.注意:不存在长度为0的像素片段.这种表示法叫做像素片段法.
 
 例如位图表示法的字节序列210,0,255对应的像素序列可以分成七个片段,分别是:11,0,1,00,1,000000000,11111111.如果用像素片段法来表示的话,二进制字节序列应该写成10000010,00000001,10000001,00000010,10000001,00001001,10001000,而其对应于十进制字节序列就是130,1,129,2,129,9,136.
 
 像素片段法是否能有效地减少图像的数据存储量呢 小可可不知道如何用数学的方法加以证明,于是决心对手头上的图像做些试验,看看该方法是否真的有效.请你编写程序完成图像信息的转换,以协助小可可完成这项试验. 
 
 Input
 输入为一行,存放了一个图像的信息.第一个数是正整数n(n<=80000),表明该图像有个像素.随后有n/8个十进制形式的字节量,表示该图像的位图信息.相邻数之间用一个空白字符隔开.
 
 Output
 输出以像素片段表示法表示的图像信息,各个数都以十进制的形式出现,每个数后面跟一个空白字符. 
 
 Sample Input
 24 210 0 255
 Sample Output
 130 1 129 2 129 9 136 
*/